package com.jlxu.demo.jvm.lifecycle;

import lombok.extern.slf4j.Slf4j;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.junit4.SpringRunner;

/**
 * 功能：JVM类生命周期概述：加载时机与加载过程
 * 创建时间：2020年04月04日
 * 文件名称：LifecycleTest
 * 版本：1.0.0
 * 最后修改时间：2020/4/4 18:51
 *
 * @auther jlxu
 */
@RunWith(SpringRunner.class)
@Slf4j
public class LifecycleTest {
    //静态块访问，赋值静态变量问题？
    //--------分析：编译器收集的顺序是由语句在源文件中出现的顺序所决定的，
    //          静态语句块只能访问到定义在静态语句块之前的变量，
    //          定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。
    static {
        i = 0;
        //System.out.println(i);//Error：Cannot reference a field before it is defined（非法向前应用）
    }

    static int i = 1;

    @Test
    public void lifecycleTest() {
        //摘要：
        // 1、我们知道一个.java文件怎么样才能被运行和使用？
        // 2、什么是类加载机制？
        // 3、本文概述了JVM加载类的时机和生命周期，并结合典型案例重点介绍了类的初始化过程，揭开了JVM类加载机制的神秘面纱。

        //友情提示：
        // JVM类加载机制主要包括两个问题：TODO： 那两个问题？  后面的问题放在 另外一篇博文中  ，明后天处理
        // 一个java对象的创建过程往往几个阶段？  见另外一篇博文，稍后处理
        // 注意，本文内容是以HotSpot虚拟机为基准的。  什么是HotSpot虚拟机  参考地址：  https://blog.csdn.net/tianshuhao/article/details/89819214

        //一、类加载机制概述
        //这里感觉是对摘要的拓展
        // java语言和其他语言的区别？ 在Java语言里面，类型的加载和连接都是在程序运行期间完成。 Java中天生可以动态扩展的语言特性多态就是依赖运行期动态加载和动态链接这个特点实现的
        // 上面这两句优点饶， 栗子：如果编写一个使用接口的应用程序，可以等到运行时再指定其实际的实现。这种组装应用程序的方式广泛应用于Java程序之中。  TODO：其实就是多态
        // 那么  虚拟机什么时候才会加载Class文件并初始化类呢？  虚拟机如何加载一个Class文件呢？  后续处理  虚拟机加载一个Class文件要经历那些具体的步骤呢？
        // 上面的1，3问题是博文要阐述的重点

        //二. 类加载的时机
        // 什么的前提下，java类的整个生命周期包括哪些阶段？ 这些阶段中哪些顺序是确定的，哪些是 不确定的？为什么？ TODO:
        // 类的加载过程必须按照这种顺序按部就班地“开始”，而不是按部就班的“进行”或“完成”？TODO: 开始？
        // 了解了生命周期，虚拟机什么时候才会加载Class文件并初始化类呢？
        //1、类加载时机
        //　什么情况下虚拟机需要开始加载一个类呢？虚拟机规范中并没有对此进行强制约束，这点可以交给虚拟机的具体实现来自由把握。
        //2、类初始化时机
        //什么情况下虚拟机需要开始初始化一个类呢？   初始化发生在什么之后呢？
        //1）字节码指令 哪些指令？其中有的指令有什么特别需要注意的地方吗？ 是什么？
        //使用new关键字实例化对象的时候；
        //读取或设置一个类的静态字段（被final修饰，已在编译器把结果放入常量池的静态字段除外）的时候；
        //调用一个类的静态方法的时候。
        //2) 使用java.lang.reflect”包的方法“对”类进行反射调用的时候“，如果类没有进行过初始化，则需要先触发其初始化。
        //3) 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
        //4) 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。
        //5) 当使用jdk1.7动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getstatic,REF_putstatic,REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。
        //第5点不明白  参考地址：https://www.cnblogs.com/web-java/p/5759376.html（了解）   TODO:ps： 3要解析看清除了（”“），
        //主动引用和被动引用？
        //什么是初始化？什么是实例化？有什么区别？
        //3、被动引用的几种经典场景
        //1)、通过子类引用父类的静态字段，不会导致子类初始化  2)、通过数组定义来引用类，不会触发此类的初始化 3)、常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化
        /**
         * 栗子
         * @see com.jlxu.demo.jvm.lifecycle.demo.NotInitialization
         * @see com.jlxu.demo.jvm.lifecycle.demo2.NotInitialization2
         * @see com.jlxu.demo.jvm.lifecycle.demo3.NotInitialization3
         */
        //为什么？TODO:

        //三. 类加载过程
        //1、加载（Loading）
        //在加载阶段虚拟机需要完成哪些事情？  TODO:
        //(1). 通过”一个类“的”全限定名“来获取”定义此类“的”二进制“”字节流“（并没有指明要从一个Class文件中获取，可以从其他渠道，譬如：网络、动态生成、数据库等）；
        //(2). 将这个字节流所代表的”静态存储结构““转化”为”方法区的运行时数据结构“；
        //(3). 在内存中(对于HotSpot虚拟就而言就是”方法区“)生成一个代表这个类的java.lang.Class对象，作为方法区”这个类“的”各种数据的访问入口“；
        //加载和校验阶段是怎么进行的？ 这里的答案解释了上面”开始“的含义
        //第一件事情(通过一个类的全限定名来获取定义此类的二进制字节流)是由类加载器完成的  前面提到了，后续处理
        //2、验证（Verification）
        //验证是连接阶段的第一步，这一阶段的目的？验证阶段大致会完成几个阶段的检验动作
        //元数据  https://www.cnblogs.com/liuyonglong/p/3567786.html  TODO：不知道这里第二个验证阶段的元数据好像和参考地址的不是一个意思
        //验证阶段小结？
        //3、准备(Preparation)
        //准备阶段导致干了
        // 什么？  分配内存和类变量初始值  在那里分配？ 方法区   类变量和实例变脸内存分配的区别/什么进行？  TODO:  TODO:这里说的是初始值 **
        //“通常情况”下是数据类型的零值? 类字段的字段属性是ConstantValue时，会在准备阶段初始化为指定的值
        // public static int value = 123;
        //分析  TODO:那么，变量value在准备阶段过后的值为0而不是123。因为这时候尚未开始执行任何java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器方法<clinit>()之中，所以把value赋值为123的动作将在初始化阶段才会执行。
        //4、解析(Resolution)
        //定义？　解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程  不懂  注意注意,针对哪些符号引用？
        //5、初始化(Initialization)
        //初始化是类加载的第几步骤？  这句话：在前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。  不懂
        //到了初始化阶段，才真正开始执行类中定义的java程序代码(字节码)。 TODO
        //什么是初始化？ 构造器<clinit>()方法？   TODO:非常重要    <clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块static{}中的语句合并产生的
        //静态块访问，赋值静态变量问题？    栗子和分析见上面   TODO:
        //正常访问见下
        System.out.println(i);
        //类构造器<clinit>()和实例构造器<init>()的区别？  特别地，类构造器<clinit>()对于类或接口时必须的吗？
        //在多线程下，谁保状类的类构造器<clinit>()被安全执行，怎么保存？ 线程是什么状态？ 特别注意什么？==> 在同一个类加载器下，一个类型只会被初始化一次
        //如果在一个类的<clinit>()方法中有耗时很长的操作，就可能造成多个线程阻塞  在实际应用中这种阻塞往往是隐藏的  栗子如下
        //ps:注意下 DeadLoopClass是一个类，类中有静态块  TODO:
        /**
         * @see com.jlxu.demo.jvm.lifecycle.demo4.DealLoopTest
         */

        //四. 典型案例分析
        //创建一个对象常常需要经历如下几个过程
        //父类的类构造器<clinit>() -> 子类的类构造器<clinit>() -> 父类的成员变量和实例代码块 -> 父类的构造函数 -> 子类的成员变量和实例代码块 -> 子类的构造函数
        //为什么？  明天处理  TODO:

        //TODO:***
        //父类的类构造器<clinit>() -> 子类的类构造器<clinit>() -> 父类的成员变量和实例代码块 -> 父类的构造函数 -> 子类的成员变量和实例代码块 -> 子类的构造函数
        //类都没有初始化完毕啊，能直接进行实例化吗？  这涉及到一个根本问题就是：实例初始化不一定要在类初始化结束之后才开始初始化。
        //初始化容易忽略的问题？类的加载？ 对于程序来说，准备阶段很重？ 为什么/准备阶段做了什么？
        //初始化分为哪些？  类和实例   实例可以多次初始化？
        //一旦开始初始化一个类型，无论是否完成，后续都不会再重新触发该类型的初始化阶段了(只考虑在同一个类加载器下的情形)。  注意这里指的是类型
        //按照程序的顺序初始化
        /**
         * 初始化经典案例
         * @see com.jlxu.demo.jvm.lifecycle.demo5.StaticTest
         * @see com.jlxu.demo.jvm.lifecycle.demo6.StaticTest
         * @see com.jlxu.demo.jvm.lifecycle.demo7.ConstructorExample   TODO:2020-4-5处理
         */


    }


}
